#include <Servo.h> // include Servo library 
#include <SoftwareSerial.h>
#include <MsTimer2.h>
SoftwareSerial BT(7,8) ;// 수신:7, 송신:8
Servo L; Servo R; Servo D;

int servoR=90, servoL=90, servoD=90;

int cdslt = A0;                   // 왼쪽 위 조도센서
int cdsrt = A1;                   // 오른쪽 위 조도센서
int cdsld = A2;                   // 왼쪽 아래 조도센서
int cdsrd = A3;                   // 오른쪽 아래 조도센서

int lt=0;
int rt=0;
int ld=0;
int rd=0;
int value = 0;
int ltValues[10];  // 필터링 하는 배열 선언
int rtValues[10];
int ldValues[10];
int rdValues[10];  

int dtime;//analogRead(4)/20; // 모터간 반응속도  // 딜레이 
int dvert ;      // 상단과 하단 조도 차이
int dhoriz  ;      // 좌측과 우측 조도 차이

int avt ;     // 상단 평균
int avd  ;    // 하단 평균
int avl ;    // 좌측 평균
int avr ;  // 우측 평균
int state=1;
void setup()
{
  Serial.begin(9600);
  BT.begin(9600);
  MsTimer2::set(1500,watch_value);
  MsTimer2::start();
  L.attach(9);                  // LT 모터 제어
  R.attach(10);                 // RT 모터 제어
  D.attach(11);                 // LD 모터 제어
            // RD 모터 제어

  for (int i = 0; i < 10; i++) {
    ltValues[i] = 0;
    rtValues[i] = 0;
    ldValues[i] = 0;
    rdValues[i] = 0;
  } // 필터링 배열
}

void loop() 
{

  get_sensor_value(); // avt, avd,avl, avr 필터링해서 받기
  int tol = 5; // 허용 오차
  if (-1*tol > dvert || dvert > tol) 
  {
   if(avt > avd)
    {
      servoR++;
      servoL--;
      if(servoR >= 180) servoR=180;
      if(servoL <= 0) servoL=0;
      if(servoR>=90) state = 0;
      else state=1;
    }
   else if(avt<avd)
   {
      servoL++;
      servoR--;
      if(servoL >= 180) servoL=180;
      if(servoR <= 0) servoR=0;
      if(servoR>=90) state = 0;
      else state=1;
   }
  }

  if (-1*tol > dhoriz || dhoriz > tol) 
  {
    if(state==1)
    {
      if(avl>avr)
      {
       servoD++;
       if(servoD>=180) {servoR=90;servoL=90;servoD=90;}
      }
      else if(avl<avr)
      {
       servoD--;
       if(servoD<=0) {servoR=90;servoL=90;servoD=90;}
      }
     
    }
    if(state==0) //기본
    {
      if(avl>avr)
      {
       servoD--;
       if(servoD<=0) servoD=90;
      }
      else if(avl<avr)
      {
       servoD++;
       if(servoD>=180) servoD=90;
      }
    
    }
  }
    L.write(servoL);
    R.write(servoR);
    D.write(servoD);            
  delay(dtime);
} 

void get_sensor_value()
{

  // 이동평균 필터링
   ltValues[9] = analogRead(cdslt);
   rtValues[9] = analogRead(cdsrt);
  ldValues[9] = analogRead(cdsld);
  rdValues[9] = analogRead(cdsrd);

  // 배열에 저장된 값들을 이용하여 이동평균 필터링 적용
  for (int i = 0; i < 9; i++) {
    ltValues[i] = ltValues[i + 1];
    rtValues[i] = rtValues[i + 1];
    ldValues[i] = ldValues[i + 1];
    rdValues[i] = rdValues[i + 1];
  }

  int ltSum = 0;
  int rtSum = 0;
  int ldSum = 0;
  int rdSum = 0;

  for (int i = 0; i < 10; i++) {
    ltSum += ltValues[i];
    rtSum += rtValues[i];
    ldSum += ldValues[i];
    rdSum += rdValues[i];
  }

  lt = ltSum / 10;
  rt = rtSum / 10;
  ld = ldSum / 10;
  rd = rdSum / 10;

  dtime = 100; // 모터간 반응속도
  
  avt = (lt + rt) / 2;      // 상단 평균
  avd = (ld + rd) / 2;      // 하단 평균
  avl = (lt + ld) / 2;      // 좌측 평균
  avr = (rt + rd) / 2;      // 우측 평균
  dvert = avt - avd;        // 상단과 하단 조도 차이
  dhoriz = avl - avr;       // 좌측과 우측 조도 차이

}


void watch_value()
{

  Serial.print("cdslt : ");
  Serial.println(lt);
  Serial.print("cdsrt : ");
  Serial.println(rt);
  Serial.print("cdsld : ");
  Serial.println(ld);
  Serial.print("cdsrd : ");
  Serial.println(rd);
  Serial.println("----");

  Serial.print("L : ");
  Serial.println(servoL);
  Serial.print("R : ");
  Serial.println(servoR);
  Serial.print("D : ");
  Serial.println(servoD);
}
